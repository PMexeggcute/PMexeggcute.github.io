<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="😘😘😘">
<meta property="og:type" content="website">
<meta property="og:title" content="Sn0r1ax">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Sn0r1ax">
<meta property="og:description" content="😘😘😘">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Sn0r1ax">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Sn0r1ax</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sn0r1ax</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Sleep all day</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/10/FreeRTOS(%E5%9B%9B)-%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Sn0r1ax">
      <meta itemprop="description" content="😘😘😘">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sn0r1ax">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/10/FreeRTOS(%E5%9B%9B)-%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">FreeRTOS学习笔记(四) 中断管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-10 22:57:22" itemprop="dateCreated datePublished" datetime="2025-12-10T22:57:22+08:00">2025-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-16 22:44:25" itemprop="dateModified" datetime="2025-12-16T22:44:25+08:00">2025-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FreeRTOS/" itemprop="url" rel="index"><span itemprop="name">FreeRTOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>大部分freertos api函数都有两个版本, 区别在于名称后面的FromISR</p>
<p>带有改后缀的, 称为中断安全函数</p>
<p>为什么执行同一功能的函数必须设计为两个版本呢</p>
<p>其根本原因是因为 在函数调用之中 如果使更高优先级的任务进入到就绪态, 该任务则会抢占当前任务</p>
<p>而在中断中不能进行上下文切换</p>
<p>那为了解决这个问题, freertos的设计采用了将其分为两个函数的做法</p>
<p>这样的优势是:</p>
<p>代码不用再去实现 辨别函数来源的逻辑 即不用去判定其是从中断中调用的还是从任务中调用的</p>
<p>确保传入的参数都是该函数会使用的, 在任务中和中断中调用函数时使用的api函数参数可能不同</p>
<p>不同freertos移植版本执行上下文机制不同</p>
<p>兼容不同架构, 中断和硬件有关</p>
<p>缺点呢:</p>
<p>在可能同时被中断和任务调用的函数中无法确定使用哪个函数</p>
<p>解决办法是使用 延迟中断处理, 即把中断处理函数统一由任务或进程守护任务调用, 而这些任务由中断进行唤醒</p>
<p>那么中断安全函数是如何解决无法在中断中切换上下文的呢</p>
<p>中断安全函数都有一个统一的参数<code>xHigherPriorityTaskWoken</code></p>
<p>这个参数有两个值, pdTRUE和pdFALSE</p>
<p>通常初始化为pdFALSE</p>
<p>在执行完一个api函数(中断安全版)之后, 如果导致更高优先级的任务变为就绪态</p>
<p>则在api函数内部会将该参数改为pdTRUE</p>
<p>最后在ISR结尾处通过调用<code>portYIELD_FROM_ISR( xHigherPriorityTaskWoken )</code>来决定是否跳转</p>
<p><code>portYIELD_FROM_ISR</code>是如何起作用的呢?</p>
<p>该函数会先判定woken参数是否为true, 如果为true则会悬起一个pendSV异常</p>
<p>这会导致当该ISR推出后 引起一个上下文切换</p>
<p>这样就避免了在中断中进行任务切换</p>
<p>示例如下, 使用的api函数为二进制信号量相关函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">ulExampleInterruptHandler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">BaseType_t xHigherPriorityTaskWoken;</span><br><span class="line"><span class="comment">/* The xHigherPriorityTaskWoken parameter must be initialized to</span></span><br><span class="line"><span class="comment">pdFALSE as it will get set to pdTRUE inside the interrupt safe</span></span><br><span class="line"><span class="comment">API function if a context switch is required. */</span></span><br><span class="line">xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line"><span class="comment">/* &#x27;Give&#x27; the semaphore to unblock the task, passing in the address of</span></span><br><span class="line"><span class="comment">xHigherPriorityTaskWoken as the interrupt safe API function&#x27;s</span></span><br><span class="line"><span class="comment">pxHigherPriorityTaskWoken parameter. */</span></span><br><span class="line">xSemaphoreGiveFromISR( xBinarySemaphore, &amp;xHigherPriorityTaskWoken );	<span class="comment">//二进制信号量</span></span><br><span class="line"><span class="comment">/* Pass the xHigherPriorityTaskWoken value into portYIELD_FROM_ISR().</span></span><br><span class="line"><span class="comment">If xHigherPriorityTaskWoken was set to pdTRUE inside</span></span><br><span class="line"><span class="comment">xSemaphoreGiveFromISR() then calling portYIELD_FROM_ISR() will request</span></span><br><span class="line"><span class="comment">a context switch. If xHigherPriorityTaskWoken is still pdFALSE then</span></span><br><span class="line"><span class="comment">calling portYIELD_FROM_ISR() will have no effect. Unlike most FreeRTOS</span></span><br><span class="line"><span class="comment">ports, the Windows port requires the ISR to return a value - the return</span></span><br><span class="line"><span class="comment">statement is inside the Windows version of portYIELD_FROM_ISR(). */</span></span><br><span class="line">portYIELD_FROM_ISR( xHigherPriorityTaskWoken );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在讲信号量之前先来了解下延迟中断处理</p>
<p>由于ISR运行时会导致内核的短暂停止</p>
<p>这可能会导致 任务的开始时间和执行时间的抖动</p>
<p>所以必须保证ISR逻辑尽量简短</p>
<p>但世事总不那么如意</p>
<p>在必须处理复杂逻辑时该怎么办呢</p>
<p>就只能使用延迟中断处理了</p>
<p>延迟中断处理在检测到中断时 唤醒处理函数</p>
<p>然后在处理函数中进行逻辑的处理</p>
<p>ISR中只需要写唤醒函数的代码即可</p>
<p><img src="/../images/FreeRTOS/11.png" alt="11"></p>
<p>那么ISR要如何唤醒一个任务呢</p>
<p>这里我们使用的是 信号量(官方推荐的是使用<strong>任务通知</strong>)</p>
<p>信号量分为二进制信号量和计数信号量</p>
<p>二进制信号量可以看作一个队列长度为1的, 队列内容无关的队列, 那么计数信号量就是队列长度不为1的, 队列内容无关的队列</p>
<p>使用流程:</p>
<p>创建一个信号量</p>
<p>中断处理任务中调用<strong>take</strong>(获取信号量函数)</p>
<p>在take发现信号量中没有信号时 该任务进入阻塞状态</p>
<p>当检测到中断发生</p>
<p>ISR中调用<strong>give</strong>(写信号量函数)</p>
<p>此时内核发现该信号量有值了, 通知中断处理任务进入就绪态</p>
<p>如果中断处理任务的优先级大于现有任务</p>
<p>则会将<code>xHigherPriorityTaskWoken</code>置为pdTRUE, 然后ISR返回后切换上下文为中断处理任务</p>
<p>中断处理任务take到信号量</p>
<p>执行中断处理逻辑</p>
<p>在下一轮执行时, take再次发现信号量为空, 进入阻塞态</p>
<p><img src="/../images/FreeRTOS/9.png" alt="9"></p>
<p>二进制信号量的问题也很明显</p>
<p>在当中断处理函数take信号量之前 如果再次发生了一个中断</p>
<p>那么第二个中断将被忽略 于是有个计数信号量</p>
<p>作用机制是相同的, 只是多了能够处理多个中断</p>
<p><img src="/../images/FreeRTOS/10.png" alt="10"></p>
<p>api函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveFromISR</span><span class="params">( SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">( UBaseType_t uxMaxCount,</span></span><br><span class="line"><span class="params">UBaseType_t uxInitialCount )</span>;</span><br></pre></td></tr></table></figure>



<p>上文还提到可以将中断处理工作延时给守护进程任务</p>
<p>优点在于:</p>
<p>能够降低资源浪费率, 无需为每个延迟中断创建单独任务</p>
<p>简化用户模型: 延迟中断处理函数是一个标准的C函数</p>
<p>缺点在于:</p>
<p>由于都是适用的守护进程任务, 那么无法为每个中断处理设置单独的优先级</p>
<p>守护进程执行函数是通过队列来获取所需要的执行函数的, 可能ISR结束后无法立即执行中断处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerPendFunctionCallFromISR</span><span class="params">( PendedFunction_t</span></span><br><span class="line"><span class="params">xFunctionToPend,</span></span><br><span class="line"><span class="params"><span class="type">void</span> *pvParameter1,</span></span><br><span class="line"><span class="params"><span class="type">uint32_t</span> ulParameter2,</span></span><br><span class="line"><span class="params">BaseType_t *pxHigherPriorityTaskWoken )</span>;	<span class="comment">//在中断中向进程守护任务发送一个函数执行指令</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPendableFunction</span><span class="params">( <span class="type">void</span> *pvParameter1, <span class="type">uint32_t</span> ulParameter2 )</span>;	<span class="comment">//函数原型 既可以使用指针类型的参数 也可以使用非指针类型参数</span></span><br></pre></td></tr></table></figure>



<p>ISR中也是可以使用队列的, 但如果只是用来传递信号 那还是信号量相对更佳(最佳的还是 任务通知)</p>
<p>在进程中使用队列也需要使用ISR专用的中断安全api函数</p>
<p>在UART程序中, 可以使用队列来接收UART传送过来的数据, 然后通过延迟中断处理计数 在任务中进行处理</p>
<p>中断是可以嵌套的</p>
<p>每个中断源都有数值优先级和逻辑优先级的属性</p>
<p>逻辑优先级高的能抢占逻辑优先级低的中断 这点和裸机一样</p>
<p>逻辑优先级由数字优先级控制</p>
<p>在CM3中, 数字优先级低的逻辑优先级越高, 这点也和裸机一样</p>
<p><img src="/../images/FreeRTOS/12.png" alt="12"></p>
<p>对于越高的优先级对ISR的执行事件越严格, 具体表现为是否能够使用api函数</p>
<p>CM3中最高循序使用8位来指定每个中断优先级</p>
<p>通常只使用八位数字的一部分</p>
<p>使用规范则是左对齐, 未使用的低有效位通常置为1</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/09/FreeRTOS(%E4%B8%89)-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Sn0r1ax">
      <meta itemprop="description" content="😘😘😘">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sn0r1ax">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/09/FreeRTOS(%E4%B8%89)-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">FreeRTOS学习笔记(三) 软件定时器管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-09 20:32:12" itemprop="dateCreated datePublished" datetime="2025-12-09T20:32:12+08:00">2025-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-16 22:44:37" itemprop="dateModified" datetime="2025-12-16T22:44:37+08:00">2025-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FreeRTOS/" itemprop="url" rel="index"><span itemprop="name">FreeRTOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="软件定时器能干嘛"><a href="#软件定时器能干嘛" class="headerlink" title="软件定时器能干嘛"></a>软件定时器能干嘛</h2><p>软件定时器功能上和硬件定时器类似, 但是软件定时器是基于系统中断由软件来模拟的定时器</p>
<p>不像硬件定时器一样占用硬件资源</p>
<p>为了启用软件定时器，需要在头文件<strong>FreeRTOSConfig.h</strong>中设置<strong>configUSE_TIMERS</strong>的值为1</p>
<p>和硬件定时器相同, 在经过设定的tick数之后, 会调用对应的回调函数</p>
<p>可以在回调函数中实现需要的逻辑</p>
<p>注意不要在回调函数中执行任何可能会导致其进入阻塞状态的函数</p>
<p>因为定时器回调函数是由进程守护任务(RTOS daemon task)执行的</p>
<p>进程守护任务具有和正常任务相同的优先级机制</p>
<p>一旦定时器回调函数进入阻塞状态, 进程守护任务也会被阻塞, 这是不合法的</p>
<p>软件定时器分一次性定时器和自动重载定时器</p>
<p>一次性定时器在运行完一次之后自动进入休眠(dormant)状态</p>
<p>而自动重载定时器在执行完一次后会重新开始</p>
<p><img src="/../images/FreeRTOS/8.png" alt="8"></p>
<p>既然定时器是由freertos守护进程任务维护的, 而启动定时器等api函数总是在别的任务中执行的</p>
<p>那么守护进程任务是如何知道在什么时候启动定时器, 又在什么时候对定时器进行操作呢</p>
<p>这就要提到上一节的队列了</p>
<p>队列作为一种任务间的通信方式, 理所应当能够作为进程守护任务与其他任务沟通的桥梁</p>
<p>当其他任务调用<code>xTimerCreate()</code>时, 会向Timer Command Queue(定时器任务列表)中发送一条指令</p>
<p>当进程守护任务从列表中读取到该指令时, 会执行相应的操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TimerHandle_t <span class="title function_">xTimerCreate</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName,	<span class="comment">//定时器名, 仅用于调试</span></span></span><br><span class="line"><span class="params"><span class="type">const</span> TickType_t xTimerPeriodInTicks,	<span class="comment">//定时器时间(tick数)</span></span></span><br><span class="line"><span class="params"><span class="type">const</span> BaseType_t xAutoReload,	<span class="comment">//是否自动重载 pdTRUE/pdFALSE</span></span></span><br><span class="line"><span class="params"><span class="type">void</span> * <span class="type">const</span> pvTimerID,			<span class="comment">//定时器ID, 可用于自定义操作, 其他api函数本身不会使用</span></span></span><br><span class="line"><span class="params">TimerCallbackFunction_t pxCallbackFunction )</span>;	<span class="comment">//回调函数指针</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerStart</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTimerSetTimerID</span><span class="params">( <span class="type">const</span> TimerHandle_t xTimer, <span class="type">void</span> *pvNewID )</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">pvTimerGetTimerID</span><span class="params">( <span class="type">const</span> TimerHandle_t xTimer )</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerChangePeriod</span><span class="params">( TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">TickType_t xNewPeriod,</span></span><br><span class="line"><span class="params">TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTimerReset</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>

<p>上述api函数如若要在中断中使用, 均需要使用其中断专用api函数, 函数名就是原函数名后面加上FromISR</p>
<p>例如<code>xTimerStartFromISR()</code></p>
<p>静态创建软件定时器<code>xTimerCreateStatic()</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/08/FreeRTOS(%E4%BA%8C)-%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Sn0r1ax">
      <meta itemprop="description" content="😘😘😘">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sn0r1ax">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/08/FreeRTOS(%E4%BA%8C)-%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">FreeRTOS学习笔记(二) 队列管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-08 21:28:02" itemprop="dateCreated datePublished" datetime="2025-12-08T21:28:02+08:00">2025-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-16 22:44:47" itemprop="dateModified" datetime="2025-12-16T22:44:47+08:00">2025-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FreeRTOS/" itemprop="url" rel="index"><span itemprop="name">FreeRTOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h2><p>用于任务与任务之间, 中断与中断之间, 任务与中断中间通信的一种方式</p>
<p>队列本身也是一种FIFO的数据结构</p>
<p>使用起来也是如此, 通过<code>xQueueSend()</code>api函数将数据发送到队列中</p>
<p>可以选择是以拷贝的形式还是以指针的形式存放于队列中</p>
<p>将数据发送进队列的时候可以选择是发送到队首还是队尾</p>
<p>队列的读取总是从队首读取数据</p>
<p>为了处理多任务间通信的问题</p>
<p>可以用结构体来储存数据</p>
<p>结构体中标明该信息的来源及数据本身</p>
<p>还可以使用队列集(Queue Set)的方式</p>
<p>不过队列集相较于结构体更不直观且效率更差</p>
<p>因此官方更推荐在可选的情况下使用结构体的方式</p>
<p>说回队列集</p>
<p>队列集就是多个队列(或信号量)的集合</p>
<p>当处于队列集中的队列收到数据时, 该队列会将其句柄发送到队列集中, 此时队列集中就有数据了</p>
<p>通过<code>xQueueSelectFromSet()</code>函数传入队列集的句柄, 以此来返回队列集中存在的队列句柄</p>
<p>在实际使用时可以通过返回的句柄与现有的句柄进行比较</p>
<p>根据不同任务的数据选择不同的处理函数</p>
<p>还有一种叫做<strong>Mailbox</strong>的用法</p>
<p>在这里, Mailbox指的是队列长度为1的队列</p>
<p>Mailbox的意思是像邮一样只储存一个数据, 发送数据到该队列时直接覆写, 而不是等待被接收方读取并删除 对应api函数为<code>xQueueOverwrite()</code> 该函数只能用于队列长度为1的队列</p>
<p>接受时也不进行删除, 而是直接获得一份拷贝 相关api函数为<code>xQueuePeek()</code></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><strong>Mastering-the-FreeRTOS-Real-Time-Kernel.v1.1.0 (Richard Barry -and- The FreeRTOS Team)</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/03/FreeRTOS(%E4%B8%80)-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Sn0r1ax">
      <meta itemprop="description" content="😘😘😘">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sn0r1ax">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/03/FreeRTOS(%E4%B8%80)-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">FreeRTOS学习笔记(一) 任务管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-03 20:07:37" itemprop="dateCreated datePublished" datetime="2025-12-03T20:07:37+08:00">2025-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-09 20:13:33" itemprop="dateModified" datetime="2025-12-09T20:13:33+08:00">2025-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FreeRTOS/" itemprop="url" rel="index"><span itemprop="name">FreeRTOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是任务"><a href="#什么是任务" class="headerlink" title="什么是任务"></a>什么是任务</h2><p>在 FreeRTOS 中，<strong>任务（Task）是内核调度的基本执行单位</strong>。<br> 它本质上是一个独立运行的函数，并且拥有自己的运行环境。</p>
<p>FreeRTOS 为每个任务分配两块独立的内存：</p>
<ul>
<li><strong>TCB（Task Control Block）</strong>：保存任务的元信息，例如优先级、状态、上下文指针等。</li>
<li><strong>任务栈（Stack）</strong>：保存此任务的局部变量、函数调用现场和寄存器上下文。</li>
</ul>
<p>任务之间的栈空间相互独立，因此每个任务可以像“单独运行”的程序一样执行自己的逻辑。</p>
<p>虽然单核 MCU 在任意时刻只能执行一条指令，但 FreeRTOS 通过<strong>优先级调度</strong>和<strong>快速的上下文切换</strong>让多个任务“轮流运行”，从而表现出类似多线程的效果。</p>
<blockquote>
<p><strong>因此，任务可以理解为：FreeRTOS 中由调度器管理的独立执行单元，是整个系统中最小的可调度对象。</strong></p>
</blockquote>
<p>一个最简单的任务长这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StartDefaultTask</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="任务的状态机及其生命周期"><a href="#任务的状态机及其生命周期" class="headerlink" title="任务的状态机及其生命周期"></a>任务的状态机及其生命周期</h2><p>一个任务包含四种状态, 刚创建时的<strong>就绪态(Ready)</strong>, 执行时的<strong>运行态(Runing)</strong>, 阻塞时的<strong>阻塞态(Blocked)</strong>, 暂停时的<strong>挂起态(Suspended)</strong></p>
<p>当然还有被<strong>delete</strong>后的状态, 这里不列入其中</p>
<h3 id="如何创建一个任务"><a href="#如何创建一个任务" class="headerlink" title="如何创建一个任务"></a>如何创建一个任务</h3><h4 id="函数参数及返回值"><a href="#函数参数及返回值" class="headerlink" title="函数参数及返回值"></a>函数参数及返回值</h4><p>FreeRTOS提供了6个api函数供我们使用, 分别是:</p>
<p><code>xTaskCreate(), xTaskCreateStatic(),xTaskCreateRestricted(), xTaskCreateRestrictedStatic(), xTaskCreateAffinitySet(), and xTaskCreateStaticAffinitySet()</code></p>
<p>其中最基础的是<code>xTaskCreate()</code>, 函数定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pvTaskCode,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,</span></span><br><span class="line"><span class="params">configSTACK_DEPTH_TYPE usStackDepth,</span></span><br><span class="line"><span class="params"><span class="type">void</span> * pvParameters,</span></span><br><span class="line"><span class="params">UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params">TaskHandle_t * pxCreatedTask )</span>;</span><br></pre></td></tr></table></figure>

<p>另外提一嘴, FreeRTOS这个项目使用的命名方法可以看作是一种<strong>匈牙利命名法的变体</strong>, 通过在变量名前加’i’, ‘u’ 之类的单词表示变量的类型</p>
<p>如uxPriority 就是指的unsigned basetype (basetype在不同的架构上位数不同, 如32位架构下是32位, 64位下则是64位)</p>
<p>话说回来, 介绍一下其中的参数及返回值</p>
<p><strong>参数:</strong></p>
<ul>
<li>pvTaskCode: 该参数为指向任务的函数的指针</li>
<li>pcName: 用于调试时显示的任务名称, 可置NULL, <code>configMAX_TASK_NAME_LEN</code>记录了其最大长度</li>
<li>usStackDepth: 用于指定分配给任务使用的堆栈大小, 该值指定的是堆栈可容纳的字节数, 即 如果该参数为128, 则会分配128 * 4 个字节的堆栈空间. <code>configSTACK_DEPTH_TYPE</code>规定了用于保存堆栈大小的数据类型, 默认为<code>uint16_t</code>, 意味着如果堆栈深度乘以堆栈宽度大于65535时会发生溢出</li>
<li>pvParameters: 用于给任务的参数传值</li>
<li>uxPriority: 该任务的优先级, 范围为0到<code>configMAX_PRIORITIES - 1</code></li>
<li>pxCreatedTask: 用于储存该任务的句柄, 可置NULL</li>
</ul>
<p><strong>返回值:</strong></p>
<ul>
<li>pdPASS: 标志着任务被成功创建</li>
<li>pdFAIL: 表明没有足够的堆内存创建任务</li>
</ul>
<h4 id="不同的任务创建函数"><a href="#不同的任务创建函数" class="headerlink" title="不同的任务创建函数"></a>不同的任务创建函数</h4><p>从另外五个函数中可以提取出这几个关键词, <strong>static</strong>, <strong>Restricted</strong>, <strong>AffinitySet</strong></p>
<p>其中:</p>
<ul>
<li>static表示使用静态的内存, 和c语言中static一个作用, 不多赘述</li>
<li>restricted表示创建的任务的权限受到限制, 无法访问系统内存</li>
<li>affinity表示可用于多核处理器的任务, 支持Symmetric Multi Processing(SMP)</li>
</ul>
<h4 id="创建任务的不同姿势"><a href="#创建任务的不同姿势" class="headerlink" title="创建任务的不同姿势"></a>创建任务的不同姿势</h4><p>简单的创建几个任务</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Variables declared here may no longer exist after starting the FreeRTOS</span></span><br><span class="line"><span class="comment">    * scheduler. Do not attempt to access variables declared on the stack used</span></span><br><span class="line"><span class="comment">    * by main() from tasks.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Create one of the two tasks. Note that a real application should check</span></span><br><span class="line"><span class="comment">    * the return value of the xTaskCreate() call to ensure the task was</span></span><br><span class="line"><span class="comment">    * created successfully.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    xTaskCreate( vTask1, <span class="comment">/* Pointer to the function that implements the task.*/</span></span><br><span class="line">    <span class="string">&quot;Task 1&quot;</span>,<span class="comment">/* Text name for the task. */</span></span><br><span class="line">    <span class="number">1000</span>, <span class="comment">/* Stack depth in words. */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">/* This example does not use the task parameter. */</span></span><br><span class="line">    <span class="number">1</span>, <span class="comment">/* This task will run at priority 1. */</span></span><br><span class="line">    <span class="literal">NULL</span> ); <span class="comment">/* This example does not use the task handle. */</span></span><br><span class="line">    <span class="comment">/* Create the other task in exactly the same way and at the same priority.*/</span></span><br><span class="line">    xTaskCreate( vTask2, <span class="string">&quot;Task 2&quot;</span>, <span class="number">1000</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span> );</span><br><span class="line">    <span class="comment">/* Start the scheduler so the tasks start executing. */</span></span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * If all is well main() will not reach here because the scheduler will now</span></span><br><span class="line"><span class="comment">    * be running the created tasks. If main() does reach here then there was</span></span><br><span class="line"><span class="comment">    * not enough heap memory to create either the idle or timer tasks</span></span><br><span class="line"><span class="comment">    * (described later in this book). Chapter 3 provides more information on</span></span><br><span class="line"><span class="comment">    * heap memory management.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个任务不止能在<code>main</code>函数里创建, 还可以在任务之中进行任务的创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTask1</span><span class="params">( <span class="type">void</span> * pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pcTaskName = <span class="string">&quot;Task 1 is running\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> ul; <span class="comment">/* volatile to ensure ul is not optimized away. */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * If this task code is executing then the scheduler must already have</span></span><br><span class="line"><span class="comment">    * been started. Create the other task before entering the infinite loop.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    xTaskCreate( vTask2, <span class="string">&quot;Task 2&quot;</span>, <span class="number">1000</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span> );</span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Print out the name of this task. */</span></span><br><span class="line">        vPrintLine( pcTaskName );</span><br><span class="line">        <span class="comment">/* Delay for a period. */</span></span><br><span class="line">        <span class="keyword">for</span>( ul = <span class="number">0</span>; ul &lt; mainDELAY_LOOP_COUNT; ul++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * This loop is just a very crude delay implementation. There is</span></span><br><span class="line"><span class="comment">            * nothing to do in here. Later examples will replace this crude</span></span><br><span class="line"><span class="comment">            * loop with a proper delay/sleep function.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过任务模板进行实例的创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskFunction</span><span class="params">( <span class="type">void</span> * pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *pcTaskName;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> ul; <span class="comment">/* volatile to ensure ul is not optimized away. */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * The string to print out is passed in via the parameter. Cast this to a</span></span><br><span class="line"><span class="comment">    * character pointer.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pcTaskName = ( <span class="type">char</span> * ) pvParameters;</span><br><span class="line">    <span class="comment">/* As per most tasks, this task is implemented in an infinite loop. */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Print out the name of this task. */</span></span><br><span class="line">        vPrintLine( pcTaskName );</span><br><span class="line">        <span class="comment">/* Delay for a period. */</span></span><br><span class="line">        <span class="keyword">for</span>( ul = <span class="number">0</span>; ul &lt; mainDELAY_LOOP_COUNT; ul++ )</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This loop is just a very crude delay implementation. There is</span></span><br><span class="line"><span class="comment">        * nothing to do in here. Later exercises will replace this crude</span></span><br><span class="line"><span class="comment">        * loop with a proper delay/sleep function.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Define the strings that will be passed in as the task parameters. These are</span></span><br><span class="line"><span class="comment">* defined const and not on the stack used by main() to ensure they remain</span></span><br><span class="line"><span class="comment">* valid when the tasks are executing.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * pcTextForTask1 = <span class="string">&quot;Task 1 is running&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * pcTextForTask2 = <span class="string">&quot;Task 2 is running&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Variables declared here may no longer exist after starting the FreeRTOS</span></span><br><span class="line"><span class="comment">    * scheduler. Do not attempt to access variables declared on the stack used</span></span><br><span class="line"><span class="comment">    * by main() from tasks.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/* Create one of the two tasks. */</span></span><br><span class="line">    xTaskCreate( vTaskFunction, <span class="comment">/* Pointer to the function that implements the task. */</span></span><br><span class="line">    <span class="string">&quot;Task 1&quot;</span>, <span class="comment">/* Text name for the task. This is to facilitate debugging only. */</span></span><br><span class="line">    <span class="number">1000</span>, <span class="comment">/* Stack depth - small  microcontrollers will use much less stack than this.*/</span></span><br><span class="line">    ( <span class="type">void</span> * ) pcTextForTask1, <span class="comment">/* Pass the text to be printed into the task using the task parameter.*/</span></span><br><span class="line">    <span class="number">1</span>, <span class="comment">/* This task will run at priority 1.*/</span></span><br><span class="line">    <span class="literal">NULL</span> ); <span class="comment">/* The task handle is not used in this example. */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Create the other task in exactly the same way. Note this time that</span></span><br><span class="line"><span class="comment">    * multiple tasks are being created from the SAME task implementation</span></span><br><span class="line"><span class="comment">    * (vTaskFunction). Only the value passed in the parameter is different.</span></span><br><span class="line"><span class="comment">    * Two instances of the same task definition are being created.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    xTaskCreate( vTaskFunction,</span><br><span class="line">    <span class="string">&quot;Task 2&quot;</span>,</span><br><span class="line">    <span class="number">1000</span>,</span><br><span class="line">    ( <span class="type">void</span> * ) pcTextForTask2,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="literal">NULL</span> );</span><br><span class="line">    <span class="comment">/* Start the scheduler so the tasks start executing. */</span></span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * If all is well main() will not reach here because the scheduler will</span></span><br><span class="line"><span class="comment">    * now be running the created tasks. If main() does reach here then there</span></span><br><span class="line"><span class="comment">    * was not enough heap memory to create either the idle or timer tasks</span></span><br><span class="line"><span class="comment">    * (described later in this book). Chapter 3 provides more information on</span></span><br><span class="line"><span class="comment">    * heap memory management.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四种状态"><a href="#四种状态" class="headerlink" title="四种状态"></a>四种状态</h3><h4 id="就绪态和运行态"><a href="#就绪态和运行态" class="headerlink" title="就绪态和运行态"></a>就绪态和运行态</h4><p>那么创建完一个任务之后, 其默认会处于<strong>就绪态</strong></p>
<p>那么有了<strong>就绪态</strong>, 我们创建一个任务肯定想要让他执行, 于是有了<strong>运行态</strong></p>
<p>运行完毕的任务回到就绪态, 然后从就绪态中选一个任务执行, 那么最简单的一个模型诞生了</p>
<p><img src="/../images/FreeRTOS/0.png" alt="0"></p>
<p>这里提一嘴优先级, 顾名思义, 优先级决定了哪个任务能够先执行</p>
<p>上文还说到, freertos通过不断地上下文切换达到”伪”多线程的目的</p>
<p>那么在每次上下文切换的时候都会根据优先级决定谁会被选中为下一个运行的任务</p>
<p>试想以下场景: 我们现在有两个优先级不同的任务, 请问这两个任务会如何执行?</p>
<p>答案显而易见, 低优先级的任务会被高优先级的任务<strong>饿死</strong></p>
<p>那么我们两个状态的模型就不够用了</p>
<p>于是诞生了<strong>阻塞态</strong>和<strong>挂起态</strong></p>
<h4 id="阻塞态和挂起态"><a href="#阻塞态和挂起态" class="headerlink" title="阻塞态和挂起态"></a>阻塞态和挂起态</h4><p>当搞优先级的任务进入阻塞态后, 那么就绪态就只剩下低优先级的任务可以执行了</p>
<p>这样, 低优先级的任务就饿不死了</p>
<p><strong>阻塞态</strong>分为两种类型:</p>
<p><strong>时间(Temporal)事件</strong>和<strong>同步(Synchronization)事件</strong></p>
<p><strong>同步事件</strong>可由FreeRTOS 队列、二进制信号量、计数信号量、互斥体、递归互斥体、事件组、流缓冲区、消息缓冲区和直接任务通知产生</p>
<p>任务可以阻塞同步事件并设置超时，从而有效地同时阻塞两种类型的事件。例如，任务可以选择等待最多 10 毫秒以便数据到达队列。如果 10 毫秒内有数据到达或 10 毫秒后没有数据到达，任务将离开阻塞状态</p>
<p><strong>时间事件</strong>会在指定时间到达或过去一定时间后发生</p>
<p>对应<code>void vTaskDelay( TickType_t xTicksToDelay )</code>和</p>
<p><code>void vTaskDelayUntil( TickType_t * pxPreviousWakeTime, TickType_t xTimeIncrement )</code>函数</p>
<p>通过这两个函数即可设定一个任务执行的频率</p>
<p>其中<code>xTicksToDelay </code>参数指的是所需等待的tick数, 通过<code>pdMS_TO_TICKS()</code>函数将毫秒数转换为tick数</p>
<p>tick数和mcu的频率挂钩, 所以通过函数将毫秒数进行转换可以避免因频率更改带来的错误</p>
<p>通过将FreeRTOSConfig.h 中的 <code>INCLUDE_vTaskSuspend</code> 设置为 1, 来启用 <code>portMAX_DELAY </code></p>
<p>将 <code>xTicksToWait</code> 设置为 <code>portMAX_DELAY </code>将导致任务无限期等待（不会超时）</p>
<p><code>pxPreviousWakeTime</code>参数指的是当前的tick数, <code>xTimeIncrement </code>指定多少tick产生一次事件</p>
<p><code>pxPreviousWakeTime</code>仅需指定一次, 之后会在函数内自增</p>
<p>两个函数不同点在于, 前者是相对的, 而后者是绝对的</p>
<p>使用示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskFunction</span><span class="params">( <span class="type">void</span> * pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * pcTaskName;</span><br><span class="line">    <span class="type">const</span> TickType_t xDelay250ms = pdMS_TO_TICKS( <span class="number">250</span> );</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * The string to print out is passed in via the parameter. Cast this to a</span></span><br><span class="line"><span class="comment">    * character pointer.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pcTaskName = ( <span class="type">char</span> * ) pvParameters;</span><br><span class="line">    <span class="comment">/* As per most tasks, this task is implemented in an infinite loop. */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Print out the name of this task. */</span></span><br><span class="line">        vPrintLine( pcTaskName );</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Delay for a period. This time a call to vTaskDelay() is used which</span></span><br><span class="line"><span class="comment">        * places the task into the Blocked state until the delay period has</span></span><br><span class="line"><span class="comment">        * expired. The parameter takes a time specified in &#x27;ticks&#x27;, and the</span></span><br><span class="line"><span class="comment">        * pdMS_TO_TICKS() macro is used (where the xDelay250ms constant is</span></span><br><span class="line"><span class="comment">        * declared) to convert 250 milliseconds into an equivalent time in</span></span><br><span class="line"><span class="comment">        * ticks.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        vTaskDelay( xDelay250ms );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskFunction</span><span class="params">( <span class="type">void</span> * pvParameters )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * pcTaskName;</span><br><span class="line">    TickType_t xLastWakeTime;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * The string to print out is passed in via the parameter. Cast this to a</span></span><br><span class="line"><span class="comment">    * character pointer.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pcTaskName = ( <span class="type">char</span> * ) pvParameters;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * The xLastWakeTime variable needs to be initialized with the current tick</span></span><br><span class="line"><span class="comment">    * count. Note that this is the only time the variable is written to</span></span><br><span class="line"><span class="comment">    * explicitly. After this xLastWakeTime is automatically updated within</span></span><br><span class="line"><span class="comment">    * vTaskDelayUntil().</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    xLastWakeTime = xTaskGetTickCount();</span><br><span class="line">    <span class="comment">/* As per most tasks, this task is implemented in an infinite loop. */</span></span><br><span class="line">    <span class="keyword">for</span>( ;; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Print out the name of this task. */</span></span><br><span class="line">        vPrintLine( pcTaskName );</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This task should execute every 250 milliseconds exactly. As per</span></span><br><span class="line"><span class="comment">        * the vTaskDelay() function, time is measured in ticks, and the</span></span><br><span class="line"><span class="comment">        * pdMS_TO_TICKS() macro is used to convert milliseconds into ticks.</span></span><br><span class="line"><span class="comment">        * xLastWakeTime is automatically updated within vTaskDelayUntil(), so</span></span><br><span class="line"><span class="comment">        * is not explicitly updated by the task.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        vTaskDelayUntil( &amp;xLastWakeTime, pdMS_TO_TICKS( <span class="number">250</span> ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>挂起态</strong></p>
<p>处于挂起状态的任务不可用于调度程序。进入挂起状态的唯一方法是通过调用 <code>vTaskSuspend() </code>API 函数，而退出状态的唯一方法是调用 <code>vTaskResume() </code>或 <code>xTaskResumeFromISR()</code> API 函数。大多数应用程序不使用挂起状态</p>
<p><img src="/../images/FreeRTOS/1.png" alt="1"></p>
<p>至此, 总结出四种状态的状态转换图</p>
<h3 id="删除-Delete-一个任务"><a href="#删除-Delete-一个任务" class="headerlink" title="删除(Delete)一个任务"></a>删除(Delete)一个任务</h3><p><code>vTaskDelete()</code> API 函数删除任务。仅当 FreeRTOSConfig.h 中的 <code>INCLUDE_vTaskDelete</code> 设置为 1 时，<code>vTaskDelete()</code> API 函数才可用</p>
<p><code>void vTaskDelete( TaskHandle_t xTaskToDelete )</code>通过传递任务句柄的指针完成删除</p>
<p>当任务被删除时，只有内核本身分配给任务的内存才会被自动释放。如果不再需要，在任务执行期间分配的任何内存或其他资源都必须显式释放</p>
<p>当任务被删除时, 内核本身分配给任务的资源由<strong>空闲任务</strong>来进行释放</p>
<p>这里暂且把空闲任务看作为一个<strong>最低优先级的</strong>, <strong>只在就绪态只存在空闲任务时才执行</strong>的一个任务</p>
<p>因为资源需要通过空闲任务来进行释放, 所以需要<strong>保证空闲任务不被饿死</strong>, 之后会说明</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>FreeRTOS通过调度器来决定什么时候执行什么任务</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><strong>FreeRTOS保证总是选择位于就绪态的最高优先级的任务进入运行态</strong></p>
<p>那么<strong>相同优先级的任务</strong>呢?</p>
<p>FreeRTOS采用<strong>循环调度</strong>的算法, 即像一个队列一样, 运行完毕的任务回到队列末尾, 位于队列首的任务被选中进入运行态</p>
<p>优先级的最大值由<code>configMAX_PRIORITIES</code>决定</p>
<p>优先级的范围从0到<code>configMAX_PRIORITIES - 1</code>, 0即最低优先级</p>
<p>对于优先级, 有两种调度程序可选, 分别是<strong>通用调度(Generic Scheduler)<strong>和</strong>架构优化调度(Architecture-Optimized Scheduler)</strong></p>
<p><strong>通用调度</strong>没有对<code>configMAX_PRIORITIES</code>施加上限, 但由于更大的值意味着需要更多的RAM以及更长的最坏情况执行时间, 所以一般来说, 建议最小化<code>configMAX_PRIORITIES</code></p>
<p><strong>架构优化调度</strong>可以根据不同的架构优化<code>configMAX_PRIORITIES</code>的值, 例如在32位架构上该值为32, 64位架构上该值为64</p>
<p>要使用架构优化调度, 只需要在FreeRTOSConfig.h 中将 <code>configUSE_PORT_optimized_TASK_SELECTION</code> 设置为 1, 为0则为通用调度</p>
<p>但不是所有FreeRTOS端口都有架构优化的实现, 可以根据<code>configUSE_PORT_optimized_TASK_SELECTION</code>的默认值来判断, 如果为1, 则说明有, 反之则无</p>
<p><strong>优先级不只能在任务创建时指定, 还可以在程序中动态进行修改</strong></p>
<p>当 FreeRTOSConfig.h 中的 <code>INCLUDE_vTaskPrioritySet</code> 设置为 1 时</p>
<p>可以使用<code>vTaskPrioritySet()</code>在程序中动态修改任务的优先级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskPrioritySet</span><span class="params">( TaskHandle_t xTask,</span></span><br><span class="line"><span class="params">UBaseType_t uxNewPriority )</span>;</span><br></pre></td></tr></table></figure>

<p>当 FreeRTOSConfig.h 中的 <code>INCLUDE_uxTaskPriorityGet</code> 设置为 1 时</p>
<p>还可以使用<code>uxTaskPriorityGet()</code>动态获取任务的优先级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskPriorityGet</span><span class="params">( TaskHandle_t xTask )</span>;</span><br></pre></td></tr></table></figure>

<h3 id="空闲任务"><a href="#空闲任务" class="headerlink" title="空闲任务"></a>空闲任务</h3><p>空闲任务, 顾名思义, 就是在没有任务可以执行时 执行的任务</p>
<p>其作用主要是起占位符作用, 因为FreeRTOS需要保证在任何时刻都有任务可以进入运行态</p>
<p>他的<strong>优先级为最低的0</strong>, 保证了不会因优先级更大而阻碍别的任务</p>
<p>空闲任务还有一个作用就是<strong>清除由<code>vTaskDelete() </code>函数残留的内核资源</strong></p>
<p>虽然空闲任务的优先级为最低的0, 但也可能存在相同的, 优先级为0的任务, 这时, 我们肯定不想空闲任务和我们的任务抢夺运行时间</p>
<p>FreeRTOSConfig.h 中的 <code>configIDLE_SHOULD_YIELD</code>决定空闲任务是否会和其他0优先级任务抢夺运行时间</p>
<p>当<code>configIDLE_SHOULD_YIELD</code>置0时, 空闲任务和其他任务一样, 遵循<strong>循环调度</strong>的算法</p>
<p>当<code>configIDLE_SHOULD_YIELD</code>置1时, 当有其他0优先级任务处于就绪态时, 空闲任务将在每次迭代中让步, 将运行时间让给其他任务</p>
<p><img src="/../images/FreeRTOS/2.png" alt="2"></p>
<p>在每次进行上下文切换时(这里每个间隔称为一个时间片, 每个事件片的末尾执行一次上下文切换), 先是由循环调度运行空闲任务, 此时空闲任务发现就绪态还有其他0优先级的任务, 于是主动让出该时间片的剩余时间.</p>
<p>t6到t7时间段还揭示了高优先级的任务是如何抢占低优先级的任务的(详见后文)</p>
<p>空闲任务是可以通过钩子函数进行hook的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationIdleHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>

<p>空闲任务挂钩的常见用途包括： </p>
<p><strong>执行低优先级、后台或连续处理功能，而无需为此目的创建应用程序任务而产生 RAM 开销。</strong></p>
<p><strong>测量空闲处理能力的量。</strong> （只有当所有较高优先级的应用程序任务都没有要执行的工作时，空闲任务才会运行；因此，测量分配给空闲任务的处理时间量可以清楚地指示空闲处理时间。）</p>
<p><strong>将处理器置于低功耗模式</strong>，在没有要执行的应用程序处理时提供一种简单且自动的节能方法（尽管可实现的节能效果低于无滴答空闲模式所实现的节能效果）。</p>
<p>空闲任务挂钩函数必须遵守以下规则:</p>
<p><strong>空闲任务挂钩函数绝不能尝试阻止或挂起自身。</strong></p>
<p>注意：**以任何方式阻止空闲任务都可能导致没有任务可进入运行状态的情况。**如果应用程序任务使用 vTaskDelete() API 函数删除自身，则空闲任务挂钩必须始终在合理的时间段内返回到其调用者。这是因为空闲任务负责清理分配给删除自身的任务的内核资源。如果空闲任务永久保留在空闲挂钩函数中，则无法进行此清理</p>
<h3 id="时间片-抢占式与协作式"><a href="#时间片-抢占式与协作式" class="headerlink" title="时间片, 抢占式与协作式"></a>时间片, 抢占式与协作式</h3><h4 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h4><p>试想当有两个优先级相同的, 连续运行(不会进入阻塞态)的任务, 如果正在运行中的那一个任务一直不主动退出的话, 那另一个任务将会被饿死</p>
<p>如何使两个同级的任务”同时”执行呢?</p>
<p>于是有了<strong>时间片(time slice)</strong></p>
<p>时间片是一段时间, 在一段时间后, 即时间片的末尾, 调用一次上下文切换, 通过循环调度, 使就绪态中的任务进入运行态</p>
<p>时间片的长度由<code>configTICK_RATE_HZ</code>决定, <code>configTICK_RATE_HZ</code>被设置为100Hz时, 指一个时间片为1 &#x2F; 100(s), 即10ms</p>
<p><code>configTICK_RATE_HZ</code> 的最佳值取决于应用程序，但典型值为 100</p>
<p><img src="/../images/FreeRTOS/3.png" alt="3"></p>
<h4 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h4><p>抢占式即高优先级会直接打断低优先级任务的执行, 上文默认是使用的抢占式算法</p>
<p>高优先级的任务通常标志着 紧急, 重要</p>
<p>因此需要保证高优先级任务从 进入就绪态 到 从就绪态进入运行态 的时间</p>
<p>任务的抢占是可以嵌套的, 这意味着在低优先级任务被高优先级任务抢占时候, 高优先级的任务是可以被更高优先级的任务所抢占</p>
<p>即使遇到时间片结束时的<strong>上下文切换</strong>, 下一个时间片仍然会执行更高优先级的任务, 因为此时就绪态中最高优先级的任务仍然是他自己</p>
<h4 id="三种调度算法"><a href="#三种调度算法" class="headerlink" title="三种调度算法"></a>三种调度算法</h4><p>是否使用时间片以及是否使用抢占式调度可以通过FreeRTOSConfig.h中<code>configUSE_PREEMPTION</code> 和 <code>configUSE_TIME_SLICING</code>的值进行配置</p>
<p>第三个配置常量 <code>configUSE_TICKLESS_IDLE</code> 也会影响调度算法, 他决定了时间片末尾的上下文切换请求在空闲时是否会关闭 以最大限度地降低功耗, 默认为0(关闭)</p>
<p><code>configUSE_PREEMPTION</code> 和 <code>configUSE_TIME_SLICING</code>的不同配置决定了程序使用哪一种调度算法</p>
<p><img src="/../images/FreeRTOS/4.png" alt="4"></p>
<p><strong>带有时间切片的固定优先级抢占式调度(Prioritized Preemptive Scheduling with Time Slicing)</strong></p>
<p><img src="/../images/FreeRTOS/5.png" alt="5"></p>
<p>这也是最为常见的一种算法</p>
<p><strong>无时间分片的优先抢占式调度(Prioritized Preemptive Scheduling without Time Slicing)</strong></p>
<p><img src="/../images/FreeRTOS/6.png" alt="6"></p>
<p>由于没有时间片提供的定期的上下文切换, 导致空闲任务一直占着cpu导致任务2执行时间远小于空闲任务(<code>configIDLE_SHOULD_YIELD</code>为0的情况)</p>
<p><strong>协同调度(Cooperative Scheduling)</strong></p>
<p><img src="/../images/FreeRTOS/7.png" alt="7"></p>
<p>协同调度算法下的任务只有在一个任务运行结束时才会进行切换</p>
<p>可用于数据传输的情况</p>
<p>例如任务1将要发送’abcdefg’</p>
<p>任务2将要发送’1234567890’</p>
<p>我们肯定不想在任务2发送期间被任务1抢占使得发送出的数据被破坏</p>
<p>但这是一个比较奇怪的例子, 使用无时间分片的优先抢占式调度, 然后将两者的任务优先级置为相同 也可以解决这个问题, 但这样必须限制发送数据的任务为相同优先级</p>
<p>而且进程间通信往往有更好的方法</p>
<h2 id="TLS与可重入"><a href="#TLS与可重入" class="headerlink" title="TLS与可重入"></a>TLS与可重入</h2><p><em>抄录</em></p>
<p>线程本地存储(TLS)允许应用程序开发人员在每个任务的任务控制块中存储任意数据。此功能最常用于存储通常由不可重入函数存储在全局变量中的数据。可重入函数是可以从多个线程安全运行而没有任何副作用的函数。当在没有线程本地存储的多线程环境中使用不可重入函数时，必须特别注意检查临界区内这些函数调用的带外结果。过度使用临界区会降低 RTOS 性能，因此线程本地存储通常优于使用临界区。到目前为止，线程本地存储最常见的用途是 C 标准库和 POSIX 系统使用的 ISO C 标准中使用的 errno 全局变量。 errno 全局用于为常见标准库函数（例如 strtof 和 strtol）提供扩展结果或错误代码</p>
<p>大多数嵌入式 libc 实现都提供 API 以确保不可重入函数可以在多线程环境中正常工作。 FreeRTOS 支持两个常用开源库的重入 API：newlib 和 picolibc。这些预构建的 C 运行时线程本地存储实现可以通过在其项目的 FreeRTOSConfig.h 文件中定义下面列出的相应宏来启用</p>
<p>应用程序开发人员可以通过在 FreeRTOSConfig.h 文件中定义以下宏来实现线程本地存储： 将 configUSE_C_RUNTIME_TLS_SUPPORT 定义为 1 以启用 C 运行时线程本地存储支持。将 configTLS_BLOCK_TYPE 定义为 c 类型，该类型应用于存储 C 运行时线程本地存储数据。将 configINIT_TLS_BLOCK 定义为初始化 C 运行时线程本地存储块时应运行的 C 代码。将 configSET_TLS_BLOCK 定义为切换新任务时应运行的 c 代码 将 configDEINIT_TLS_BLOCK 定义为在取消初始化 C 运行时线程本地存储块时应运行的 c 代码</p>
<h2 id="上下文切换原理"><a href="#上下文切换原理" class="headerlink" title="上下文切换原理"></a>上下文切换原理</h2><p>当在任务中手动调用<code>vTaskStartScheduler()</code>第一次启动调度器时会触发<strong>SVC异常</strong></p>
<p>OS收到请求后在SVC Handler中做好上下文切换的准备, 同时悬起一个pendSV异常</p>
<p>当CPU退出SVC且被嵌套的中断例程执行结束后, 进入pendSV, 进行上下文切换</p>
<p>在任务中手动调用<code>taskYIELD()</code>时会直接悬起一个pendSV异常</p>
<p>一个时间片末尾产生的Systick中断现象与手动调用<code>taskYIELD()</code>相同</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/115382535">FreeRTOS 从入门到精通5–任务管理这件事（上）</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/127953272">FreeRTOS 从入门到精通6–任务管理这件事（下）（对比PLC，安卓）</a></p>
<p><strong>Mastering-the-FreeRTOS-Real-Time-Kernel.v1.1.0 (Richard Barry -and- The FreeRTOS Team)</strong></p>
<p><strong>Cortex-M3权威指南(Joseph Yiu 著 宋岩 译 <a target="_blank" rel="noopener" href="http://www.ouravr.com热心网友/">www.ouravr.com热心网友</a> 校对)</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/28/HAL%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Sn0r1ax">
      <meta itemprop="description" content="😘😘😘">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sn0r1ax">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/28/HAL%E5%BA%93/" class="post-title-link" itemprop="url">HAL库学习随笔</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-11-28 20:58:41" itemprop="dateCreated datePublished" datetime="2025-11-28T20:58:41+08:00">2025-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-12-01 15:09:16" itemprop="dateModified" datetime="2025-12-01T15:09:16+08:00">2025-12-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/11/28/HAL%E5%BA%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/11/27/CAN%E6%80%BB%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Sn0r1ax">
      <meta itemprop="description" content="😘😘😘">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sn0r1ax">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/11/27/CAN%E6%80%BB%E7%BA%BF/" class="post-title-link" itemprop="url">CAN总线学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-11-27 22:44:33 / 修改时间：22:46:03" itemprop="dateCreated datePublished" datetime="2025-11-27T22:44:33+08:00">2025-11-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CAN/" itemprop="url" rel="index"><span itemprop="name">CAN</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/11/27/CAN%E6%80%BB%E7%BA%BF/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/07/15/l3hcf2025-wp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Sn0r1ax">
      <meta itemprop="description" content="😘😘😘">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sn0r1ax">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/15/l3hcf2025-wp/" class="post-title-link" itemprop="url">l3hcf2025 wp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-07-15 17:16:03" itemprop="dateCreated datePublished" datetime="2025-07-15T17:16:03+08:00">2025-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-26 21:33:52" itemprop="dateModified" datetime="2025-09-26T21:33:52+08:00">2025-09-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/07/15/l3hcf2025-wp/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/04/%E4%BB%8ED-Link_DIR815%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E5%85%B8%E6%BC%8F%E6%B4%9E%E5%BC%80%E5%90%AFIOT%E4%B9%8B%E6%97%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Sn0r1ax">
      <meta itemprop="description" content="😘😘😘">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sn0r1ax">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/06/04/%E4%BB%8ED-Link_DIR815%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E5%85%B8%E6%BC%8F%E6%B4%9E%E5%BC%80%E5%90%AFIOT%E4%B9%8B%E6%97%85/" class="post-title-link" itemprop="url">从D-Link_DIR815路由器经典漏洞开启IOT之旅</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-06-04 20:36:59" itemprop="dateCreated datePublished" datetime="2025-06-04T20:36:59+08:00">2025-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-08 21:04:49" itemprop="dateModified" datetime="2025-06-08T21:04:49+08:00">2025-06-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>个人感觉麻烦的点在于环境的搭建(又回到最初一瓶农夫山泉搁那配一天环境的日子,一个点没注意就出问题,甚至桌上的农夫山泉都换成了怡宝),本文着重记录下自己踩得坑,对于漏洞的详细分析可以看看参考文章.然后关于IOT通信还涉及到http协议和cgi,我也以我的理解简单介绍下</p>
<p>还介绍了纯rop链和shellcode两种漏洞利用方法,提到shellcode来getshell时出现的一些问题</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/06/04/%E4%BB%8ED-Link_DIR815%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%8F%E5%85%B8%E6%BC%8F%E6%B4%9E%E5%BC%80%E5%90%AFIOT%E4%B9%8B%E6%97%85/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/31/MIPS%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Sn0r1ax">
      <meta itemprop="description" content="😘😘😘">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sn0r1ax">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/31/MIPS%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">MIPS基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-31 13:37:27" itemprop="dateCreated datePublished" datetime="2025-05-31T13:37:27+08:00">2025-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-26 21:12:14" itemprop="dateModified" datetime="2025-09-26T21:12:14+08:00">2025-09-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/05/31/MIPS%E5%9F%BA%E7%A1%80/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/27/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Sn0r1ax">
      <meta itemprop="description" content="😘😘😘">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sn0r1ax">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/27/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">正则表达式入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-27 19:47:42" itemprop="dateCreated datePublished" datetime="2025-05-27T19:47:42+08:00">2025-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-26 21:12:50" itemprop="dateModified" datetime="2025-09-26T21:12:50+08:00">2025-09-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/05/27/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sn0r1ax"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Sn0r1ax</p>
  <div class="site-description" itemprop="description">😘😘😘</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/PMexeggcute" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PMexeggcute" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sn0r1ax</span>
</div>

<!-- <br /> --> <!-- 网站运行时间的设置 --> <span id="timeDate">载入天数...</span> <!-- <span id="times">载入时分秒...</span> --> <script>   var now = new Date();   function createtime() {     var grt= new Date("11/17/2022 8:00:00");//此处修改你的建站时间或者网站上线时间     now.setTime(now.getTime()+250);     days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);     hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);     if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);     mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}     seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);     snum = Math.round(seconds);      if(String(snum).length ==1 ){snum = "0" + snum;}     // var times = document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";     document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "+hnum + " 小时 " + mnum + " 分 " + snum + " 秒";   } setInterval("createtime()",250); </script>

<!-- <br /> -->
<!-- 网站运行时间的设置 -->
<span id="timeDate">...</span>
<!-- <span id="times">载入时分秒...</span> -->
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("3/10/2025 8:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); 
        if(String(snum).length ==1 ){snum = "0" + snum;}
        // var times = document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "+hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
